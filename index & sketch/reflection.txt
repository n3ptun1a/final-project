reflection

I found in most of my time with programming in P5, I was looking at libraries & references. Especially while still developing my skills, as was apparent in sketch 1, I spent hours upon hours flipping through the shape references in order to develop the most accurate depiction of my crop that I could. However, on that same note, it was during that project that I progressively had to refer to these libraries and such less and less, maybe it was a hot streak, but I was able to adapt quickly. Understanding what each input actually did, and learning how bezier curves worked over time helped smoothen the process of the programming itself. I think this also carried on into the wallpaper sketch (sketch 3), where once the first wallpaper was completed, it was easier to understand, through the use of for loops and what not, how to consistently duplicate shapes and patterns throughout the window. I think this made for more consistent results with my projects overall, and helped me become a more efficient programmer. To be frank, I enjoyed sketch 1 the most, despite the rigorous hard coding that went into it. I felt more satisfied watching each process perform each task, as it feels that with OOP sometimes makes it hard to maintain all of the progress you've made when just looking at the flesh of the code itself. This may be due to my inexperience as a programmer thus far, and in this particular language, but it goes without saying that I would love to sit down and recreate art again. For me, the differnece between OOP and Procedural Programming can be analyzed in a metaphor of the skeleton; in OOP, you name each bone, then the skeleton, and index the tendons and muscles, which focuses on the more notable moving mechanisms rather than the nitty gritty. In procedural programming, you are aware of each bone, tendon, and ligament, and you can develop each one meticulously to build the body from the ground up, perhaps like god did with clay. If so, what a genius programmer, that guy. Anyway, in reference to my final project, I was able to, through both OOP and Procedural, develop more vector skills, alongside math, to develop collision physics, movement, and interactivity. In my midterm, there were many simpler inputs, such as just clicking the screen, and then the button in the bottom left, but in this final, I used mousePressed() and more to make the user see real time change in an actively changing environment through their inputs. In reference to the entire scheme of the final, I was largely unable to resolve bugs through the first run. I was able to view my program through the openprocessing window, until I used libraries and such that just weren't compatible; that's when I turned to HTML(which i shouldve used sooner), in order to run my program through my browser, as encouraged. However, I just couldn't grasp it, through youtube tutorials, even ChatGPT, I couldn't garner an answer to how to develop my noise interactive ball game any further. To be frank, this broke my heart, as it was a vision of mine from the start of the semester to work with sound and incorporate it into my project. I hope I can use the code that I was able to produce from then, and with further experience, generate a project that resembles my true vision. That ball project was my intended milestone, to introduce volume and pitch into the playground that I consider my program, and to that extent, I failed. However, in that same vein, I was able to produce physics mechanics which I would have otherwise used in my ball program, into my gold program, which still has a ball! That, I am satisfied with. I am most proud of making a functional game, as it has been a dream of mine since I was young to just make a game. Didn't matter how it was played, or if it was playable, but I have known that I wanted to create an interactive user experience and here, I believe I have delivered. I know I have to move forward with programming, even if it kicks my butt more often than not, and I hope to not disappoint myself moving on as much as I have this semester. In my retaking of CS 1114, and Web Development in the future, I hope I can truly become a "programmer", not a "programming student".